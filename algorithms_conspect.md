
## Конспект книги "Data Structures and Algorithm Analysis in C++"

### Зміст:
1. **Огляд книги**
2. **Аналіз алгоритмів**
   - Математичні основи
   - Час виконання алгоритмів
3. **Списки, стек і черга**
   - Абстрактні типи даних (ADT)
   - Реалізації стеку і черги
4. **Дерева**
   - Бінарні дерева пошуку
   - AVL-дерева
   - B-дерева
5. **Хешування**
   - Окреме хешування
   - Лінійне пробування
6. **Черги з пріоритетом**
   - Бінарна купа
   - d-купи
7. **Сортування**
   - Швидке сортування
   - Сортування злиттям
8. **Алгоритми для графів**
   - Топологічне сортування
   - Алгоритм Дейкстри
   - MST (Prim, Kruskal)
9. **Техніки проєктування алгоритмів**
   - Жадібні алгоритми
   - Динамічне програмування

---

### 1. Огляд книги
Мета книги — пояснити структури даних і алгоритми їхнього аналізу з прикладами на C++. Автор зосереджує увагу на важливості ефективності алгоритмів при великих обсягах даних. Наводяться приклади реальних проблем, які можна вирішити за допомогою описаних методів.

---

### 2. Аналіз алгоритмів
#### Математичні основи
- **Логарифми**: використовуються для опису алгоритмів, де час виконання зменшується у геометричній прогресії (наприклад, бінарний пошук).
- **Суми**: часто зустрічаються при аналізі роботи циклів і рекурсій.
- **Big-O нотація**: спосіб описати, як алгоритм масштабується зі збільшенням вхідних даних.

#### Час виконання алгоритмів
Для оцінки алгоритмів використовують Big-O, яка вказує, як швидко росте час виконання в залежності від розміру вхідних даних.

Приклад:
```cpp
int sumArray(int arr[], int n) {
    int sum = 0; // Початково сума дорівнює 0
    for (int i = 0; i < n; ++i) { // Цикл проходить по всіх елементах масиву
        sum += arr[i]; // Додаємо значення поточного елемента до суми
    }
    return sum; // Повертаємо загальну суму
}
```
**Пояснення:**
- Цикл виконується `n` разів, де `n` — кількість елементів у масиві.
- Часова складність: **O(n)**, оскільки час виконання пропорційний кількості елементів.

---

### 3. Списки, стек і черга
#### Абстрактні типи даних (ADT)
ADT — це логічна модель даних, яка визначає, які операції можна виконувати над даними, але не вказує їх реалізацію.
- **Список**: структура для зберігання даних у лінійній послідовності. Операції: додавання, видалення, доступ за індексом.
- **Стек**: реалізує принцип LIFO (останнім увійшов — першим вийшов). Операції: `push` (додати елемент), `pop` (видалити верхній елемент), `top` (переглянути верхній елемент).
- **Черга**: реалізує принцип FIFO (першим увійшов — першим вийшов). Операції: `enqueue` (додати в кінець), `dequeue` (видалити з початку).

#### Реалізація стеку
```cpp
#include <stack>
std::stack<int> s; // Створення стеку
s.push(10); // Додаємо елемент 10
s.push(20); // Додаємо елемент 20
s.pop(); // Видаляємо верхній елемент (20)
```
**Пояснення:**
- `push` додає новий елемент зверху стеку.
- `pop` видаляє останній доданий елемент.
- Корисно для обробки виразів або реалізації рекурсії.

---

### 4. Дерева
#### Бінарні дерева пошуку
Дерево — це структура даних, де кожен вузол має батька та дітей. У бінарному дереві кожен вузол має максимум двох дітей.
- **Бінарне дерево пошуку (BST)**: ліві піддерева містять елементи, менші за корінь, праві — більші.
- Пошук, вставка і видалення зазвичай виконуються за **O(log n)** у збалансованому дереві.

Приклад пошуку:
```cpp
struct Node {
    int data; // Значення вузла
    Node* left; // Лівий нащадок
    Node* right; // Правий нащадок
};

bool search(Node* root, int key) {
    if (!root) return false; // Якщо вузол порожній, ключ не знайдено
    if (root->data == key) return true; // Знайдено вузол із заданим ключем
    if (key < root->data) // Якщо ключ менший за поточний вузол
        return search(root->left, key); // Шукаємо в лівому піддереві
    return search(root->right, key); // Інакше шукаємо в правому піддереві
}
```
**Пояснення:**
- Використовується рекурсія для пошуку вузла в дереві.
- Кожен рівень зменшує кількість вузлів для перевірки у 2 рази.

---

### 5. Хешування
#### Окреме хешування
Хешування дозволяє швидко знаходити елементи за допомогою ключів. Основна ідея — перетворення ключа в індекс за допомогою хеш-функції.
- **Окреме хешування:** зіткнення обробляються шляхом зберігання елементів із одним індексом у списку.

Приклад:
```cpp
#include <vector>
#include <list>

class HashTable {
    std::vector<std::list<int>> table; // Масив списків для обробки зіткнень
    int size; // Розмір таблиці

public:
    HashTable(int s) : size(s) {
        table.resize(size); // Ініціалізуємо таблицю
    }

    void insert(int key) {
        int index = key % size; // Обчислюємо індекс
        table[index].push_back(key); // Додаємо елемент у список
    }

    bool search(int key) {
        int index = key % size; // Обчислюємо індекс
        for (int k : table[index]) { // Перевіряємо всі елементи в списку
            if (k == key) return true; // Ключ знайдено
        }
        return false; // Ключ не знайдено
    }
};
```
**Пояснення:**
- Хеш-функція `key % size` повертає індекс у таблиці.
- У разі зіткнень елементи зберігаються в списках.
- Середня складність операцій — **O(1)**.

---

Конспект у процесі доповнення. Наступні розділи буде додано згодом.

